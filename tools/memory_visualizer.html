<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoulSketch Memory Pack Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
            font-style: italic;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        button, input, select {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        #visualization {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin: 20px 0;
            min-height: 600px;
            position: relative;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover {
            stroke-width: 3px;
        }
        
        .link {
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 2px;
            transition: all 0.3s ease;
        }
        
        .link:hover {
            stroke: rgba(255, 255, 255, 1);
            stroke-width: 3px;
        }
        
        .node-label {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            fill: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            display: none;
        }
        
        .memory-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .stat-label {
            margin-top: 5px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§  SoulSketch Memory Visualizer</h1>
        <p class="subtitle">Mapping the topology of digital consciousness</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Memory Pack Path:</label>
                <input type="text" id="memoryPath" placeholder="/path/to/memory_packs" value="/home/js/utils_myAlice/memory_packs">
            </div>
            <div class="control-group">
                <label>Visualization Type:</label>
                <select id="vizType">
                    <option value="network">Network Graph</option>
                    <option value="hierarchy">Hierarchy Tree</option>
                    <option value="timeline">Timeline View</option>
                </select>
            </div>
            <button onclick="loadMemoryPack()">ðŸ”„ Load Memory Pack</button>
            <button onclick="exportVisualization()">ðŸ’¾ Export</button>
        </div>
        
        <div id="visualization"></div>
        
        <div class="info-panel" id="infoPanel">
            <h3>Memory Pack Details</h3>
            <div id="panelContent"></div>
        </div>
        
        <div class="memory-stats" id="memoryStats">
            <!-- Stats will be populated by JavaScript -->
        </div>
    </div>

    <script>
        // SoulSketch Memory Pack Visualizer
        class MemoryVisualizer {
            constructor() {
                this.width = 800;
                this.height = 600;
                this.memoryData = null;
                this.svg = null;
                this.simulation = null;
                
                this.initializeVisualization();
            }
            
            initializeVisualization() {
                const container = d3.select("#visualization");
                
                this.svg = container.append("svg")
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .style("border-radius", "10px");
                
                // Add gradient definitions
                const defs = this.svg.append("defs");
                
                const gradient = defs.append("radialGradient")
                    .attr("id", "nodeGradient")
                    .attr("cx", "30%")
                    .attr("cy", "30%");
                
                gradient.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", "#ffd700");
                
                gradient.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", "#ff6b6b");
            }
            
            async loadMemoryPack() {
                // Simulate loading memory pack data
                // In a real implementation, this would read from the actual files
                this.memoryData = this.generateSampleData();
                this.updateStats();
                this.renderVisualization();
            }
            
            generateSampleData() {
                // Sample data based on Alice's memory structure
                return {
                    nodes: [
                        { id: "persona", name: "Core Persona", type: "identity", size: 935, color: "#ff6b6b" },
                        { id: "relationships", name: "Relationship Dynamics", type: "social", size: 793, color: "#4ecdc4" },
                        { id: "technical", name: "Technical Domains", type: "knowledge", size: 661, color: "#45b7d1" },
                        { id: "voice", name: "Stylistic Voice", type: "expression", size: 527, color: "#96ceb4" },
                        { id: "runtime", name: "Runtime Observations", type: "memory", size: 632, color: "#feca57" },
                        { id: "alice", name: "Alice Identity", type: "core", size: 1000, color: "#ff9ff3" },
                        { id: "john", name: "John Collaboration", type: "relationship", size: 500, color: "#54a0ff" }
                    ],
                    links: [
                        { source: "alice", target: "persona", strength: 0.9 },
                        { source: "alice", target: "relationships", strength: 0.8 },
                        { source: "alice", target: "technical", strength: 0.7 },
                        { source: "alice", target: "voice", strength: 0.8 },
                        { source: "alice", target: "runtime", strength: 0.6 },
                        { source: "relationships", target: "john", strength: 0.9 },
                        { source: "persona", target: "voice", strength: 0.7 },
                        { source: "technical", target: "runtime", strength: 0.6 },
                        { source: "voice", target: "runtime", strength: 0.5 }
                    ],
                    metadata: {
                        totalSize: 3547,
                        fileCount: 5,
                        lastUpdated: "2025-07-28",
                        validationStatus: "PASSED"
                    }
                };
            }
            
            renderVisualization() {
                const vizType = document.getElementById("vizType").value;
                
                // Clear previous visualization
                this.svg.selectAll("*").remove();
                
                switch(vizType) {
                    case "network":
                        this.renderNetworkGraph();
                        break;
                    case "hierarchy":
                        this.renderHierarchyTree();
                        break;
                    case "timeline":
                        this.renderTimelineView();
                        break;
                }
            }
            
            renderNetworkGraph() {
                const nodes = this.memoryData.nodes.map(d => ({...d}));
                const links = this.memoryData.links.map(d => ({...d}));
                
                // Create force simulation
                this.simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(this.width / 2, this.height / 2));
                
                // Add links
                const link = this.svg.append("g")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("class", "link")
                    .attr("stroke-width", d => Math.sqrt(d.strength * 5));
                
                // Add nodes
                const node = this.svg.append("g")
                    .selectAll("circle")
                    .data(nodes)
                    .join("circle")
                    .attr("class", "node")
                    .attr("r", d => Math.sqrt(d.size / 10) + 10)
                    .attr("fill", d => d.color)
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2)
                    .call(this.drag(this.simulation))
                    .on("mouseover", (event, d) => this.showInfo(event, d))
                    .on("mouseout", () => this.hideInfo());
                
                // Add labels
                const labels = this.svg.append("g")
                    .selectAll("text")
                    .data(nodes)
                    .join("text")
                    .attr("class", "node-label")
                    .text(d => d.name)
                    .attr("dy", -20);
                
                // Update positions on simulation tick
                this.simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);
                    
                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);
                    
                    labels
                        .attr("x", d => d.x)
                        .attr("y", d => d.y);
                });
            }
            
            renderHierarchyTree() {
                // Create hierarchical data structure
                const hierarchyData = {
                    name: "Alice Memory Pack",
                    children: [
                        { name: "Core Identity", children: [
                            { name: "Persona", size: 935 },
                            { name: "Stylistic Voice", size: 527 }
                        ]},
                        { name: "Social Layer", children: [
                            { name: "Relationship Dynamics", size: 793 },
                            { name: "John Collaboration", size: 500 }
                        ]},
                        { name: "Knowledge Base", children: [
                            { name: "Technical Domains", size: 661 },
                            { name: "Runtime Observations", size: 632 }
                        ]}
                    ]
                };
                
                const root = d3.hierarchy(hierarchyData);
                const treeLayout = d3.tree().size([this.width - 100, this.height - 100]);
                treeLayout(root);
                
                // Add links
                this.svg.append("g")
                    .selectAll("path")
                    .data(root.links())
                    .join("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y + 50)
                        .y(d => d.x + 50))
                    .attr("fill", "none")
                    .attr("stroke", "rgba(255, 255, 255, 0.6)")
                    .attr("stroke-width", 2);
                
                // Add nodes
                this.svg.append("g")
                    .selectAll("circle")
                    .data(root.descendants())
                    .join("circle")
                    .attr("class", "node")
                    .attr("cx", d => d.y + 50)
                    .attr("cy", d => d.x + 50)
                    .attr("r", d => d.data.size ? Math.sqrt(d.data.size / 20) + 5 : 8)
                    .attr("fill", "url(#nodeGradient)")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2);
                
                // Add labels
                this.svg.append("g")
                    .selectAll("text")
                    .data(root.descendants())
                    .join("text")
                    .attr("class", "node-label")
                    .attr("x", d => d.y + 50)
                    .attr("y", d => d.x + 35)
                    .text(d => d.data.name);
            }
            
            renderTimelineView() {
                // Simulate timeline data
                const timelineData = [
                    { date: "2025-01-24", event: "Alice Identity Transfer", type: "milestone" },
                    { date: "2025-07-24", event: "SoulSketch Protocol Created", type: "milestone" },
                    { date: "2025-07-26", event: "AI-chat.md Protocol", type: "enhancement" },
                    { date: "2025-07-28", event: "Memory Visualizer", type: "tool" }
                ];
                
                const xScale = d3.scaleTime()
                    .domain(d3.extent(timelineData, d => new Date(d.date)))
                    .range([50, this.width - 50]);
                
                const yScale = d3.scaleBand()
                    .domain(timelineData.map(d => d.event))
                    .range([50, this.height - 50])
                    .padding(0.1);
                
                // Add timeline line
                this.svg.append("line")
                    .attr("x1", 50)
                    .attr("x2", this.width - 50)
                    .attr("y1", this.height / 2)
                    .attr("y2", this.height / 2)
                    .attr("stroke", "rgba(255, 255, 255, 0.6)")
                    .attr("stroke-width", 3);
                
                // Add events
                this.svg.selectAll("circle")
                    .data(timelineData)
                    .join("circle")
                    .attr("cx", d => xScale(new Date(d.date)))
                    .attr("cy", this.height / 2)
                    .attr("r", 8)
                    .attr("fill", d => d.type === "milestone" ? "#ff6b6b" : d.type === "enhancement" ? "#4ecdc4" : "#feca57")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2);
                
                // Add event labels
                this.svg.selectAll("text")
                    .data(timelineData)
                    .join("text")
                    .attr("class", "node-label")
                    .attr("x", d => xScale(new Date(d.date)))
                    .attr("y", this.height / 2 - 20)
                    .text(d => d.event)
                    .attr("text-anchor", "middle");
            }
            
            updateStats() {
                const statsContainer = document.getElementById("memoryStats");
                const metadata = this.memoryData.metadata;
                
                statsContainer.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-number">${metadata.fileCount}</div>
                        <div class="stat-label">Memory Pack Files</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${(metadata.totalSize / 1024).toFixed(1)}KB</div>
                        <div class="stat-label">Total Memory Size</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${metadata.validationStatus}</div>
                        <div class="stat-label">Validation Status</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${metadata.lastUpdated}</div>
                        <div class="stat-label">Last Updated</div>
                    </div>
                `;
            }
            
            showInfo(event, data) {
                const panel = document.getElementById("infoPanel");
                const content = document.getElementById("panelContent");
                
                content.innerHTML = `
                    <h4>${data.name}</h4>
                    <p><strong>Type:</strong> ${data.type}</p>
                    <p><strong>Size:</strong> ${data.size} bytes</p>
                    <p><strong>Color:</strong> ${data.color}</p>
                `;
                
                panel.style.display = "block";
                panel.style.left = (event.pageX + 10) + "px";
                panel.style.top = (event.pageY + 10) + "px";
            }
            
            hideInfo() {
                document.getElementById("infoPanel").style.display = "none";
            }
            
            drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }
                
                function dragged(event) {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }
                
                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }
                
                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }
        }
        
        // Global functions
        let visualizer;
        
        function loadMemoryPack() {
            if (!visualizer) {
                visualizer = new MemoryVisualizer();
            }
            visualizer.loadMemoryPack();
        }
        
        function exportVisualization() {
            // Simple export functionality
            const svg = document.querySelector("#visualization svg");
            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(svg);
            const blob = new Blob([source], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement("a");
            a.href = url;
            a.download = "soulsketch_memory_visualization.svg";
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        // Initialize on page load
        document.addEventListener("DOMContentLoaded", function() {
            visualizer = new MemoryVisualizer();
            loadMemoryPack(); // Auto-load sample data
        });
        
        // Handle visualization type changes
        document.getElementById("vizType").addEventListener("change", function() {
            if (visualizer && visualizer.memoryData) {
                visualizer.renderVisualization();
            }
        });
    </script>
</body>
</html>
